{
    "docs": [
        {
            "location": "/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nxpcc: C++ microcontroller framework \n#\n\n\nThe xpcc framework consists of powerful hardware abstraction layers for many\ndifferent microcontrollers, a set of drivers for various external targets and a general purpose toolbox for building hardware orientated applications.\n\n\nThe main goal of xpcc is to provide a usable API for barebone microcontroller programming,\nwhich is efficient enough to be deployed on a small ATtiny, yet powerful enough to make\nuse of advanced capabilities found on the 32bit ARM Cortex-M.\n\n\nxpcc is \nbattle-tested\n in the real-world, highly competitive\nenvironment of \nEurobot\n.\nIt is the foundation of all of \n@RCA_eV\n's robot code, and is the\nculmination of many years worth of effort, experience and improvements.\n\n\n\n\nFeast your eyes on lots of working examples\n.\n\n\nAPI reference is available here\n.\n\n\nWe have continuous integration as well\n.\n\n\n\n\n\nThis project also has \nguide for developers\n as well as a \ntechnical blog\n to document larger design concepts.\n\n\n\n\nYou have questions? \nAsk them on our mailing list\n\nor \nhave a look at the archive\n.\n\n\nYou found a bug? \nOpen up an issue, we don't bite\n.\n\n\nYou want to contribute? \nRead the contribution guidelines\n and \nopen a pull request so we can merge it\n.\n\n\n\n\nThe source code is freely available under a 3-clause BSD license, so feel\nfree to fork this project and adapt it to your needs.\nThe only thing we ask of you is to contribute your changes back.\nThat way everyone can profit.\n\n\nFeatures\n#\n\n\n\n\nEfficient and fast object-oriented C++11 API.\n\n\nSupport of AVR and ARM Cortex-M based microcontrollers from Atmel, ST and NXP.\n\n\nBuild system based on SCons and extendable using Python.\n\n\nData-driven HAL generation using Jinja2 template engine.\n\n\nNo memory allocations in HAL with very low overall RAM consumption.\n\n\nCross platform peripheral interfaces incl. bit banging:\n\n\nGPIO \n GPIO expanders\n\n\nADC\n\n\nUART, I2C, SPI\n\n\nCAN\n\n\n\n\n\n\nInterfaces for external I2C and SPI device drivers.\n\n\nDebug/logging system with IOStream interface.\n\n\nLightweight, stackless threads and resumable functions using cooperative multitasking.\n\n\nUseful mathematical and geometric algorithms optimized for microcontrollers.\n\n\nLightweight unit testing system (suitable for AVRs).\n\n\nGraphical user interface for small binary displays.\n\n\n\n\nSupported hardware\n#\n\n\nHere is a list of supported \nand tested\n microcontrollers and development boards:\n\n\n\n\n\n\n\n\nController\n\n\nDevelopment Board\n\n\nSupport\n\n\n\n\n\n\n\n\n\n\nAT90can\n\n\ncustom\n\n\n\n\n\n\n\n\nATtiny44a\n\n\ncustom\n\n\n\n\n\n\n\n\nATtiny85\n\n\ncustom\n\n\n\n\n\n\n\n\nATmega328p\n\n\nArduino Uno\n\n\n\n\n\n\n\n\nSTM32F072\n\n\nSTM32F072 Discovery\n\n\n\n\n\n\n\n\nSTM32F100\n\n\nSTM32F1 Discovery\n\n\n\n\n\n\n\n\nSTM32F103\n\n\nSTM32F103 Nucleo\n\n\n\n\n\n\n\n\nSTM32F303\n\n\nSTM32F3 Discovery\n\n\n\n\n\n\n\n\nSTM32F407\n\n\nSTM32F4 Discovery\n\n\n\n\n\n\n\n\nSTM32F429\n\n\nSTM32F429 Discovery\n\n\n\n\n\n\n\n\nSTM32F469\n\n\nSTM32F469 Discovery\n\n\n\n\n\n\n\n\nSTM32F746\n\n\nSTM32F7 Discovery\n\n\n\n\n\n\n\n\nLPC11C24\n\n\nLPCxpresso\n\n\n\n\n\n\n\n\n\n\nAll of these targets are compiling and booting correctly\n(\n)\nand have GPIO and UART working\n(\n).\nMost targets have support for basic peripherals, like I2C, SPI and ADC\n(\n)\nas well as complicated peripherals, like Timers, CAN and external memory\n(\n).\nWe also use a few targets in everyday development, which are very well tested\n(\n).\n\n\nPlease see \nour examples for a complete list\n of tested projects.\n\n\nYour target\n#\n\n\nWhile the xpcc API is designed to be portable, we are only a small team of developers and are limited in the amount of platforms we can support and test in hardware.\nThe following microcontrollers should be able to compile, but \nhave not been tested extensively\n in hardware:\n\n\n\n\nAll AT90 targets\n\n\nAll ATtiny targets\n\n\nAll ATmega targets\n\n\nAll STM32F0 targets\n\n\nAll STM32F1 targets\n\n\nAll STM32F3 targets\n\n\nAll STM32F4 targets\n\n\nAll STM32F7 targets\n\n\n\n\nThere are more platforms which we have prepared, but currently not finished support for (Xmega, STM32F2, STM32L).\n\nDrop us an email\n to ask if your specific target is supported out-of-the-box and what you can do if it's not.\n\n\nWho we are\n#\n\n\nDuring the last decade the \nRoboterclub Aachen e.V.\n has developed a software library for communication among components that are distributed on PCs and microcontrollers. This library was used in autonomous robots for the \nEurobot competition\n.\n\n\nIn 2009, xpcc became a separate project and since then focussed on a new approach to cross target microcontroller libraries. Over the years xpcc grew from a communication library to a general purpose framework suitable for all kinds of embedded applications.\n\n\nThe xpcc project is maintained by\nNiklas Hauser (\n@salkinium\n) and\nKevin L\u00e4ufer (\n@ekiwi\n) with significant contributions from\nFabian Greif (\n@dergraaf\n),\nDaniel Krebs (\n@daniel-k\n),\n\n@georgi-g\n and\n\n@thundernail\n.\n\n\nHave a look at the quarter finals of the \nEurobot 2015 competition\n.\nBoth our robots are running xpcc and starting from the right:", 
            "title": "Home"
        }, 
        {
            "location": "/#xpcc-c-microcontroller-framework", 
            "text": "The xpcc framework consists of powerful hardware abstraction layers for many\ndifferent microcontrollers, a set of drivers for various external targets and a general purpose toolbox for building hardware orientated applications.  The main goal of xpcc is to provide a usable API for barebone microcontroller programming,\nwhich is efficient enough to be deployed on a small ATtiny, yet powerful enough to make\nuse of advanced capabilities found on the 32bit ARM Cortex-M.  xpcc is  battle-tested  in the real-world, highly competitive\nenvironment of  Eurobot .\nIt is the foundation of all of  @RCA_eV 's robot code, and is the\nculmination of many years worth of effort, experience and improvements.   Feast your eyes on lots of working examples .  API reference is available here .  We have continuous integration as well .   This project also has  guide for developers  as well as a  technical blog  to document larger design concepts.   You have questions?  Ask them on our mailing list \nor  have a look at the archive .  You found a bug?  Open up an issue, we don't bite .  You want to contribute?  Read the contribution guidelines  and  open a pull request so we can merge it .   The source code is freely available under a 3-clause BSD license, so feel\nfree to fork this project and adapt it to your needs.\nThe only thing we ask of you is to contribute your changes back.\nThat way everyone can profit.", 
            "title": "xpcc: C++ microcontroller framework "
        }, 
        {
            "location": "/#features", 
            "text": "Efficient and fast object-oriented C++11 API.  Support of AVR and ARM Cortex-M based microcontrollers from Atmel, ST and NXP.  Build system based on SCons and extendable using Python.  Data-driven HAL generation using Jinja2 template engine.  No memory allocations in HAL with very low overall RAM consumption.  Cross platform peripheral interfaces incl. bit banging:  GPIO   GPIO expanders  ADC  UART, I2C, SPI  CAN    Interfaces for external I2C and SPI device drivers.  Debug/logging system with IOStream interface.  Lightweight, stackless threads and resumable functions using cooperative multitasking.  Useful mathematical and geometric algorithms optimized for microcontrollers.  Lightweight unit testing system (suitable for AVRs).  Graphical user interface for small binary displays.", 
            "title": "Features"
        }, 
        {
            "location": "/#supported-hardware", 
            "text": "Here is a list of supported  and tested  microcontrollers and development boards:     Controller  Development Board  Support      AT90can  custom     ATtiny44a  custom     ATtiny85  custom     ATmega328p  Arduino Uno     STM32F072  STM32F072 Discovery     STM32F100  STM32F1 Discovery     STM32F103  STM32F103 Nucleo     STM32F303  STM32F3 Discovery     STM32F407  STM32F4 Discovery     STM32F429  STM32F429 Discovery     STM32F469  STM32F469 Discovery     STM32F746  STM32F7 Discovery     LPC11C24  LPCxpresso      All of these targets are compiling and booting correctly\n( )\nand have GPIO and UART working\n( ).\nMost targets have support for basic peripherals, like I2C, SPI and ADC\n( )\nas well as complicated peripherals, like Timers, CAN and external memory\n( ).\nWe also use a few targets in everyday development, which are very well tested\n( ).  Please see  our examples for a complete list  of tested projects.", 
            "title": "Supported hardware"
        }, 
        {
            "location": "/#your-target", 
            "text": "While the xpcc API is designed to be portable, we are only a small team of developers and are limited in the amount of platforms we can support and test in hardware.\nThe following microcontrollers should be able to compile, but  have not been tested extensively  in hardware:   All AT90 targets  All ATtiny targets  All ATmega targets  All STM32F0 targets  All STM32F1 targets  All STM32F3 targets  All STM32F4 targets  All STM32F7 targets   There are more platforms which we have prepared, but currently not finished support for (Xmega, STM32F2, STM32L). Drop us an email  to ask if your specific target is supported out-of-the-box and what you can do if it's not.", 
            "title": "Your target"
        }, 
        {
            "location": "/#who-we-are", 
            "text": "During the last decade the  Roboterclub Aachen e.V.  has developed a software library for communication among components that are distributed on PCs and microcontrollers. This library was used in autonomous robots for the  Eurobot competition .  In 2009, xpcc became a separate project and since then focussed on a new approach to cross target microcontroller libraries. Over the years xpcc grew from a communication library to a general purpose framework suitable for all kinds of embedded applications.  The xpcc project is maintained by\nNiklas Hauser ( @salkinium ) and\nKevin L\u00e4ufer ( @ekiwi ) with significant contributions from\nFabian Greif ( @dergraaf ),\nDaniel Krebs ( @daniel-k ), @georgi-g  and @thundernail .  Have a look at the quarter finals of the  Eurobot 2015 competition .\nBoth our robots are running xpcc and starting from the right:", 
            "title": "Who we are"
        }, 
        {
            "location": "/why-use-xpcc/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nWhy use xpcc?\n#\n\n\n\n\n\n\n\n\nxpcc is tailored for the harsh requirements of the \nEurobot competition\n,\nwhere our robots need to run reliably and completely autonomously for the games\nduration. Furthermore, our robots started off running on AVRs, so xpcc also\nneeds to be very efficient with its resources to be able to support these tiny\nmicrocontrollers.\nAll in all, this means we need a really robust and safe foundation to build all\nour code upon.\n\n\nThis foundation is xpcc.\nIt runs very reliably and efficiently on AVR as well as ARM Cortex-M cores.\nHere are the reasons why.\n\n\nData-driven design\n#\n\n\nThe most unique thing about xpcc is how we generate our hardware abstraction\nlayer (HAL) drivers.\nWe have assembled the unique meta data of all of our targets, such as number\nand type of peripherals, pins, memories and interrupts.\nThis way we know which devices are similar to each other even before opening the\ndatasheet, and we can make informed decisions about what HAL drivers an entire\n\nfamily\n of devices requires, rather than going through this cumbersome process\nfor each device individually.\n\n\nThis dramatically reduces duplicated code, required a lot less porting effort\nand leads to much higher device coverage of our HAL drivers.\nBy combining the specific device meta data with our driver templates, we\ncollect the similarities and differences between device families in one common\nplace, which makes it so much easier to reason about them.\n\n\nThis extract from the \nSTM32F407 device file\n shows\nseveral types of peripheral drivers as well as additional information like\ninstances and pin alternate functions:\n\n\n...\n\ndriver\n \ntype=\nadc\n \nname=\nstm32\n \ninstances=\n1,2,3\n/\n\n\ndriver\n \ntype=\nclock\n \nname=\nstm32\n/\n\n\ndriver\n \ntype=\ni2c\n \nname=\nstm32\n \ninstances=\n1,2,3\n/\n\n\ndriver\n \ntype=\nuart\n \nname=\nstm32\n \ninstances=\n1,2,3,4,5,6\n/\n\n\ndriver\n \ntype=\ngpio\n \nname=\nstm32\n\n  \ngpio\n \nport=\nA\n \nid=\n0\n\n    \naf\n \nid=\n1\n \nperipheral=\nTimer2\n \nname=\nChannel1\n/\n\n    \naf\n \nid=\n8\n \nperipheral=\nUart4\n \nname=\nTx\n \ntype=\nout\n/\n\n    \naf\n \nperipheral=\nAdc1\n \nname=\nChannel0\n \ntype=\nanalog\n/\n\n  \n/gpio\n\n  ...\n\n\n\n\n\nThis information is then passed to our \nHAL drivers\n, which use\ncode generation tools, specifically the \nJinja2 template engine\n, to\ngenerate the appropriate C++ code structures for the specified target:\n\n:\n:\nA\nD\nC\nT\ne\nm\np\nl\na\nt\ne\nG\np\ni\no\nB\n2\nT\na\nr\ng\ne\nt\nD\ne\nv\ni\nc\ne\nF\ni\nl\ne\nG\nP\nI\nO\nT\ne\nm\np\nl\na\nt\ne\nG\np\ni\no\nB\n3\nI\n2\nC\nT\ne\nm\np\nl\na\nt\ne\nG\np\ni\no\nB\n4\n:\n:\n\n\nThis treasure trove of information is available for \nevery AVR and STM32\ndevice\n we support and gives us a high confidence\nin the quality of our HAL ports.\n\n\nUsable \n fast C++\n#\n\n\nxpcc's APIs are kept simple and fast by splitting up functionality into\nseparate, small, static functions, which implement the same behavior on all\nplatforms.\nFurthermore, with our code generation capabilities, we can hide the crazy\nimplementation details of the hardware without compromising on performance.\n\n\nFor example, on different AVRs, simple things like enabling the internal PullUp resistor,\ndealing with external interrupts or even just toggling a pin is done quite dissimilarly.\nYet, using static inlined functions we can call GPIO functions at \nludicrous speed\n,\nall without using even a single byte of static RAM:\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB1\n;\n   \n// Generated by GPIO HAL driver using meta-data.\n\n\nLed\n::\nsetOutput\n();\n           \n// Sets the pin to output on any platform.\n\n\nLed\n::\nset\n();\n                 \n// Literally 1 instruction on AVR.\n\n\nLed\n::\ntoggle\n();\n              \n// PORTA ^= 0x02;  or  PINA = 0x02;  if available.\n\n\n\nusing\n \nButton\n \n=\n \nGpioInputA0\n;\n \n// All pins behave the same way.\n\n\nButton\n::\nsetInput\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n  \n// PORTA |= 0x01;  or  PUEA |= 0x01;\n\n\nbool\n \nstate\n \n=\n \nButton\n::\nread\n();\n                \n// (PINA \n 0x01)  or\n\n\nButton\n::\nsetInputTrigger\n(\nGpio\n::\nInputTrigger\n::\nRisingEdge\n);\n  \n// Don\nt panic!\n\n\nButton\n::\nenableExternalInterrupt\n();\n          \n// Something, something, EIMSK.\n\n\nButton\n::\nacknowledgeExternalInterruptFlag\n();\n \n// don\nt worry, we will do it!\n\n\n\n\n\n\nYou can use these GPIOs as building blocks for more complex drivers and\nperipherals and still maintain access speed without sacrificing usability:\n\n\n// Create a hardware accelerated port of 4 bit width.\n\n\nusing\n \nPort4\n \n=\n \nGpioPort\n \nGpioC0\n,\n \n4\n \n;\n        \n// MSB -\n C3, C2, C1, C0 \n- LSB\n\n\nusing\n \nReadWrite\n \n=\n \nGpioC4\n;\n                   \n// \nname\n your GPIOs.\n\n\nusing\n \nReset\n \n=\n \nGpioOutputC5\n;\n\n\nusing\n \nEnable\n \n=\n \nGpioOutputC6\n;\n\n\n\n// Build a super fast character display driver using these inlined GPIOs.\n\n\nxpcc\n::\nHd44780\nPort4\n,\n \nReadWrite\n,\n \nReset\n,\n \nEnable\n \ndisplay\n;\n\n\ndisplay\n.\ninitialize\n();\n   \n// driver knows to initialize for a 4 bit bus!\n\n\ndisplay\n \n \nHello World!\n \n \nxpcc\n::\nendl\n;\n    \n// Yes, ostreams. Deal with it.\n\n\n\n\n\n\nAll other HAL drivers are build using these principles, which makes them easy\nto configure and use yet very fast without consuming a lot of resources.\n\n\nStatic allocation\n#\n\n\nNowhere in our HAL do we allocate memory dynamically \u2013 everything is either\nstatically allocated or must explicitly be allocated by the user.\nThis is a strong requirement to be able to run xpcc on AVRs, which have\nlittle if any memory to spare for dynamic allocations.\n\n\nWe took great care to make sure this constraint remains usable, starting with\nconfigurable queue sizes for buffered UART to providing statically extensible\nI2C state machine for custom IC drivers.\nWhen we allocate static memory, we choose an appropriate size for its purpose.\nAfter all, just because you \ncan\n use \nint\n doesn't mean you \nshould\n.\n\n\nWe transparently show you how much static memory your application is using,\nso you get an idea of how much certain functionality costs you in resources.\nThis is the size of the accelerometer example on the STM32F3 discovery board:\n\n\ncd\n examples/stm32f3_discovery/accelerometer\nscons\n\n[\n...\n]\n\nMemory Usage\n------------\nDevice: stm32f303vc\n\nProgram:    \n5188\n bytes \n(\n2.0% used\n)\n\n\n(\n.data + .reset + .rodata + .text\n)\n\n\nData:       \n3092\n bytes \n(\n6.3% used\n)\n \n=\n \n852\n bytes static \n(\n1.7%\n)\n + \n2240\n bytes stack \n(\n4.6%\n)\n\n\n(\n.bss + .data + .noinit + .stack\n)\n\n\nHeap:      \n38352\n bytes \n(\n78.0% available\n)\n\n\n(\n.heap1\n)\n\n\n\n\n\n\nCompile-time assertions\n#\n\n\nxpcc stands out for its extensive use of static C++ classes and templates which\nis unusual in this field, but lends itself well to the static nature of\nembedded development.\nBy combining modern C++11 features like \nconstexpr\n functions with the meta-data\ninside our HAL drivers, we can add additional type checks and move certain\ncomputations into compile-time, with obvious speed and usability improvements.\n\n\nAs an example, consider how xpcc connects GPIOs to peripherals and computes\nbaudrates at compile time\n1\n:\n\n\n// The specific UART connect type is unique to this GPIO.\n\n\nGpioA2\n::\nconnect\n(\nUart0\n::\nTx\n);\n\n\nGpioA3\n::\nconnect\n(\nUart0\n::\nRx\n,\n \nGpio\n::\nInputType\n::\nPullUp\n);\n\n\n// Connecting a type to the wrong GPIO will simply _not compile_!\n\n\nGpioA0\n::\nconnect\n(\nUart0\n::\nTx\n);\n \n\u26a1\n   \n// PA0 does not have this alternate function!\n\n\n\n// Enforce the UART baudrate with a 1% tolerance, otherwise compilation error!\n\n\nUart0\n::\ninitialize\nsystemClock\n,\n \n115200\n();\n   \n// prescalers computed at compile-time\n\n\n\n\n\n\nBy moving these checks into compile time, xpcc can prevent predictable failures\nbefore the code ever makes it to the target, and remove the need for expensive\ncomputations at runtime altogether, which pays off especially on AVRs!\nAnother interesting side effect is that your code \nis\n your documentation, with\nits correctness transparently enforced at compile-time.\n\n\nMultitasking\n#\n\n\nxpcc uses stackless cooperative multitasking, for which we have ported\n\nprotothreads\n to C++ and extended them with \nresumable functions\n.\nThis enables you to split up your application into separate tasks, and use\nsynchronous APIs in all of them, without sacrificing overall responsiveness.\nThis works on even the most resource restricted AVRs, since each task only\nrequires 2 bytes!\n\n\nAll our IC drivers are implemented using resumable functions, which can be\ncalled from within protothreads or explicitly blocking outside of them.\nHere is an example of \nreading out the accelerometer\n:\n\n\nclass\n \nReaderThread\n \n:\n \npublic\n \nxpcc\n::\npt\n::\nProtothread\n\n\n{\n\n\npublic\n:\n\n    \nbool\n \nrun\n()\n\n    \n{\n\n        \nPT_BEGIN\n();\n\n        \n// The driver does several I2C transfer here to initialize and configure the\n\n        \n// external sensor. The CPU is free to do other things while this happens though.\n\n        \nPT_CALL\n(\naccelerometer\n.\nconfigure\n(\naccelerometer\n.\nScale\n::\nG2\n));\n\n\n        \nwhile\n \n(\ntrue\n)\n    \n// this feels quite similar to regular threads\n\n        \n{\n\n            \n// this resumable function will defer execution back to other protothreads\n\n            \nPT_CALL\n(\naccelerometer\n.\nreadAcceleration\n());\n\n\n            \n// smooth out the acceleration data a little bit\n\n            \naverageX\n.\nupdate\n(\naccelerometer\n.\ngetData\n().\ngetX\n());\n\n            \naverageY\n.\nupdate\n(\naccelerometer\n.\ngetData\n().\ngetY\n());\n\n\n            \n// set the boards LEDs depending on the acceleration values\n\n            \nLedUp\n::\nset\n(\n   \naverageX\n.\ngetValue\n()\n \n \n-\n0.2\n);\n\n            \nLedDown\n::\nset\n(\n \naverageX\n.\ngetValue\n()\n \n  \n0.2\n);\n\n            \nLedLeft\n::\nset\n(\n \naverageY\n.\ngetValue\n()\n \n \n-\n0.2\n);\n\n            \nLedRight\n::\nset\n(\naverageY\n.\ngetValue\n()\n \n  \n0.2\n);\n\n\n            \n// defer back to other protothreads until the timer fires\n\n            \nPT_WAIT_UNTIL\n(\ntimer\n.\nexecute\n());\n\n        \n}\n\n        \nPT_END\n();\n\n    \n}\n\n\nprivate\n:\n\n    \n// This accelerometer is connected via I2C.\n\n    \nxpcc\n::\nLis3dsh\n \nxpcc\n::\nLis3TransportI2c\n \nI2cMaster\n \n \n \naccelerometer\n;\n\n    \nxpcc\n::\nPeriodicTimer\n \ntimer\n \n=\n \nxpcc\n::\nPeriodicTimer\n(\n5\n);\n \n// 5ms periodic timer.\n\n    \nxpcc\n::\nfilter\n::\nMovingAverage\nfloat\n,\n \n25\n \naverageX\n;\n\n    \nxpcc\n::\nfilter\n::\nMovingAverage\nfloat\n,\n \n25\n \naverageY\n;\n\n\n};\n\n\nReaderThread\n \nreader\n;\n    \n// Protothread is statically allocated!\n\n\n\nint\n \nmain\n()\n \n// Execution entry point.\n\n\n{\n\n    \nwhile\n(\ntrue\n)\n\n    \n{\n   \n// the main loop with implicit round robin cooperative scheduling.\n\n        \nreader\n.\nrun\n();\n\n        \notherProtothreads\n.\nrun\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputing and Asserting Baudrate Settings at Compile Time", 
            "title": "Why use xpcc?"
        }, 
        {
            "location": "/why-use-xpcc/#why-use-xpcc", 
            "text": "xpcc is tailored for the harsh requirements of the  Eurobot competition ,\nwhere our robots need to run reliably and completely autonomously for the games\nduration. Furthermore, our robots started off running on AVRs, so xpcc also\nneeds to be very efficient with its resources to be able to support these tiny\nmicrocontrollers.\nAll in all, this means we need a really robust and safe foundation to build all\nour code upon.  This foundation is xpcc.\nIt runs very reliably and efficiently on AVR as well as ARM Cortex-M cores.\nHere are the reasons why.", 
            "title": "Why use xpcc?"
        }, 
        {
            "location": "/why-use-xpcc/#data-driven-design", 
            "text": "The most unique thing about xpcc is how we generate our hardware abstraction\nlayer (HAL) drivers.\nWe have assembled the unique meta data of all of our targets, such as number\nand type of peripherals, pins, memories and interrupts.\nThis way we know which devices are similar to each other even before opening the\ndatasheet, and we can make informed decisions about what HAL drivers an entire family  of devices requires, rather than going through this cumbersome process\nfor each device individually.  This dramatically reduces duplicated code, required a lot less porting effort\nand leads to much higher device coverage of our HAL drivers.\nBy combining the specific device meta data with our driver templates, we\ncollect the similarities and differences between device families in one common\nplace, which makes it so much easier to reason about them.  This extract from the  STM32F407 device file  shows\nseveral types of peripheral drivers as well as additional information like\ninstances and pin alternate functions:  ... driver   type= adc   name= stm32   instances= 1,2,3 /  driver   type= clock   name= stm32 /  driver   type= i2c   name= stm32   instances= 1,2,3 /  driver   type= uart   name= stm32   instances= 1,2,3,4,5,6 /  driver   type= gpio   name= stm32 \n   gpio   port= A   id= 0 \n     af   id= 1   peripheral= Timer2   name= Channel1 / \n     af   id= 8   peripheral= Uart4   name= Tx   type= out / \n     af   peripheral= Adc1   name= Channel0   type= analog / \n   /gpio \n  ...  This information is then passed to our  HAL drivers , which use\ncode generation tools, specifically the  Jinja2 template engine , to\ngenerate the appropriate C++ code structures for the specified target: : : A D C T e m p l a t e G p i o B 2 T a r g e t D e v i c e F i l e G P I O T e m p l a t e G p i o B 3 I 2 C T e m p l a t e G p i o B 4 : :  This treasure trove of information is available for  every AVR and STM32\ndevice  we support and gives us a high confidence\nin the quality of our HAL ports.", 
            "title": "Data-driven design"
        }, 
        {
            "location": "/why-use-xpcc/#usable-fast-c", 
            "text": "xpcc's APIs are kept simple and fast by splitting up functionality into\nseparate, small, static functions, which implement the same behavior on all\nplatforms.\nFurthermore, with our code generation capabilities, we can hide the crazy\nimplementation details of the hardware without compromising on performance.  For example, on different AVRs, simple things like enabling the internal PullUp resistor,\ndealing with external interrupts or even just toggling a pin is done quite dissimilarly.\nYet, using static inlined functions we can call GPIO functions at  ludicrous speed ,\nall without using even a single byte of static RAM:  using   Led   =   GpioOutputB1 ;     // Generated by GPIO HAL driver using meta-data.  Led :: setOutput ();             // Sets the pin to output on any platform.  Led :: set ();                   // Literally 1 instruction on AVR.  Led :: toggle ();                // PORTA ^= 0x02;  or  PINA = 0x02;  if available.  using   Button   =   GpioInputA0 ;   // All pins behave the same way.  Button :: setInput ( Gpio :: InputType :: PullUp );    // PORTA |= 0x01;  or  PUEA |= 0x01;  bool   state   =   Button :: read ();                  // (PINA   0x01)  or  Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge );    // Don t panic!  Button :: enableExternalInterrupt ();            // Something, something, EIMSK.  Button :: acknowledgeExternalInterruptFlag ();   // don t worry, we will do it!   You can use these GPIOs as building blocks for more complex drivers and\nperipherals and still maintain access speed without sacrificing usability:  // Create a hardware accelerated port of 4 bit width.  using   Port4   =   GpioPort   GpioC0 ,   4   ;          // MSB -  C3, C2, C1, C0  - LSB  using   ReadWrite   =   GpioC4 ;                     //  name  your GPIOs.  using   Reset   =   GpioOutputC5 ;  using   Enable   =   GpioOutputC6 ;  // Build a super fast character display driver using these inlined GPIOs.  xpcc :: Hd44780 Port4 ,   ReadWrite ,   Reset ,   Enable   display ;  display . initialize ();     // driver knows to initialize for a 4 bit bus!  display     Hello World!     xpcc :: endl ;      // Yes, ostreams. Deal with it.   All other HAL drivers are build using these principles, which makes them easy\nto configure and use yet very fast without consuming a lot of resources.", 
            "title": "Usable &amp; fast C++"
        }, 
        {
            "location": "/why-use-xpcc/#static-allocation", 
            "text": "Nowhere in our HAL do we allocate memory dynamically \u2013 everything is either\nstatically allocated or must explicitly be allocated by the user.\nThis is a strong requirement to be able to run xpcc on AVRs, which have\nlittle if any memory to spare for dynamic allocations.  We took great care to make sure this constraint remains usable, starting with\nconfigurable queue sizes for buffered UART to providing statically extensible\nI2C state machine for custom IC drivers.\nWhen we allocate static memory, we choose an appropriate size for its purpose.\nAfter all, just because you  can  use  int  doesn't mean you  should .  We transparently show you how much static memory your application is using,\nso you get an idea of how much certain functionality costs you in resources.\nThis is the size of the accelerometer example on the STM32F3 discovery board:  cd  examples/stm32f3_discovery/accelerometer\nscons [ ... ] \nMemory Usage\n------------\nDevice: stm32f303vc\n\nProgram:     5188  bytes  ( 2.0% used )  ( .data + .reset + .rodata + .text ) \n\nData:        3092  bytes  ( 6.3% used )   =   852  bytes static  ( 1.7% )  +  2240  bytes stack  ( 4.6% )  ( .bss + .data + .noinit + .stack ) \n\nHeap:       38352  bytes  ( 78.0% available )  ( .heap1 )", 
            "title": "Static allocation"
        }, 
        {
            "location": "/why-use-xpcc/#compile-time-assertions", 
            "text": "xpcc stands out for its extensive use of static C++ classes and templates which\nis unusual in this field, but lends itself well to the static nature of\nembedded development.\nBy combining modern C++11 features like  constexpr  functions with the meta-data\ninside our HAL drivers, we can add additional type checks and move certain\ncomputations into compile-time, with obvious speed and usability improvements.  As an example, consider how xpcc connects GPIOs to peripherals and computes\nbaudrates at compile time 1 :  // The specific UART connect type is unique to this GPIO.  GpioA2 :: connect ( Uart0 :: Tx );  GpioA3 :: connect ( Uart0 :: Rx ,   Gpio :: InputType :: PullUp );  // Connecting a type to the wrong GPIO will simply _not compile_!  GpioA0 :: connect ( Uart0 :: Tx );   \u26a1     // PA0 does not have this alternate function!  // Enforce the UART baudrate with a 1% tolerance, otherwise compilation error!  Uart0 :: initialize systemClock ,   115200 ();     // prescalers computed at compile-time   By moving these checks into compile time, xpcc can prevent predictable failures\nbefore the code ever makes it to the target, and remove the need for expensive\ncomputations at runtime altogether, which pays off especially on AVRs!\nAnother interesting side effect is that your code  is  your documentation, with\nits correctness transparently enforced at compile-time.", 
            "title": "Compile-time assertions"
        }, 
        {
            "location": "/why-use-xpcc/#multitasking", 
            "text": "xpcc uses stackless cooperative multitasking, for which we have ported protothreads  to C++ and extended them with  resumable functions .\nThis enables you to split up your application into separate tasks, and use\nsynchronous APIs in all of them, without sacrificing overall responsiveness.\nThis works on even the most resource restricted AVRs, since each task only\nrequires 2 bytes!  All our IC drivers are implemented using resumable functions, which can be\ncalled from within protothreads or explicitly blocking outside of them.\nHere is an example of  reading out the accelerometer :  class   ReaderThread   :   public   xpcc :: pt :: Protothread  {  public : \n     bool   run () \n     { \n         PT_BEGIN (); \n         // The driver does several I2C transfer here to initialize and configure the \n         // external sensor. The CPU is free to do other things while this happens though. \n         PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); \n\n         while   ( true )      // this feels quite similar to regular threads \n         { \n             // this resumable function will defer execution back to other protothreads \n             PT_CALL ( accelerometer . readAcceleration ()); \n\n             // smooth out the acceleration data a little bit \n             averageX . update ( accelerometer . getData (). getX ()); \n             averageY . update ( accelerometer . getData (). getY ()); \n\n             // set the boards LEDs depending on the acceleration values \n             LedUp :: set (     averageX . getValue ()     - 0.2 ); \n             LedDown :: set (   averageX . getValue ()      0.2 ); \n             LedLeft :: set (   averageY . getValue ()     - 0.2 ); \n             LedRight :: set ( averageY . getValue ()      0.2 ); \n\n             // defer back to other protothreads until the timer fires \n             PT_WAIT_UNTIL ( timer . execute ()); \n         } \n         PT_END (); \n     }  private : \n     // This accelerometer is connected via I2C. \n     xpcc :: Lis3dsh   xpcc :: Lis3TransportI2c   I2cMaster       accelerometer ; \n     xpcc :: PeriodicTimer   timer   =   xpcc :: PeriodicTimer ( 5 );   // 5ms periodic timer. \n     xpcc :: filter :: MovingAverage float ,   25   averageX ; \n     xpcc :: filter :: MovingAverage float ,   25   averageY ;  };  ReaderThread   reader ;      // Protothread is statically allocated!  int   main ()   // Execution entry point.  { \n     while ( true ) \n     {     // the main loop with implicit round robin cooperative scheduling. \n         reader . run (); \n         otherProtothreads . run (); \n     }  }       Computing and Asserting Baudrate Settings at Compile Time", 
            "title": "Multitasking"
        }, 
        {
            "location": "/installation/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nInstallation\n#\n\n\nVirtual machine\n#\n\n\nIf you just want to try out xpcc or do not want to install the build tools on\nyour machine just yet, we provide you with a \nconfigured headless\nvirtual machine\n running Ubuntu\n14.04LTS with all the build tools installed.\n\n\nYou only need to install \nVirtualbox\n\nand \nVagrant\n on your system, and can\nthen easily boot the VM and ssh into it:\n\n\ngit clone https://github.com/roboterclubaachen/xpcc.git\n\ncd\n xpcc\nvagrant up\nvagrant ssh\n\n\n\n\n\nVagrant will download the virtual machine (~1.2GB), import it into VirtualBox\nand boot it, before logging into to it. There will be a shared folder located\nat \n/vagrant\n which contains the xpcc source code on your local file system.\nThis means you can use an editor of your choice to view and edit the source\ncode on you native OS, and then use the virtual machine to compile it.\n\n\nSo if you have an Arduino Uno lying around, you can then compile\nthe \nLED blinking example\n:\n\n\ncd\n /vagrant/examples/arduino_uno/basic/blink/\nscons\n\n[\n...\n]\n\nAVR Memory Usage\n----------------\nDevice: atmega328p\n\nProgram:     \n192\n bytes \n(\n0.6% used\n)\n\n\n(\n.data + .text\n)\n\n\nData:          \n0\n bytes \n(\n0.0% used\n)\n\n\n(\n.bss + .data + .noinit\n)\n\n\n\n\n\n\nYou can compile every other example the same way.\nHere is the output of the STM32F4 Discovery Board \nLED blinking example\n:\n\n\ncd\n /vagrant/examples/stm32f4_discovery/blink/\nscons\n\n[\n...\n]\n\nMemory Usage\n------------\nDevice: stm32f407vg\n\nProgram:    \n1980\n bytes \n(\n0.2% used\n)\n\n\n(\n.data + .fastdata + .reset + .rodata + .text\n)\n\n\nData:       \n3352\n bytes \n(\n1.7% used\n)\n \n=\n \n24\n bytes static \n(\n0.0%\n)\n + \n3328\n bytes stack \n(\n1.7%\n)\n\n\n(\n.bss + .data + .fastdata + .noinit + .stack\n)\n\n\nHeap:     \n131060\n bytes \n(\n66.7% available\n)\n\n\n(\n.heap1 + .heap2 + .heap3\n)\n\n\n\n\n\n\nTo program your board, just connect your board the the virtual machine and\ntype \nscons program\n.\nHave a quick look at \nthe available build system commands\n so you know what else you can do.\n\n\nNative installation\n#\n\n\nCompiling the code in our virtual machine can be slower than compiling it\nnatively. To install the toolchain on your system, this is the\nminimum required software for the xpcc build system:\n\n\n\n\nPython 2.7.x\n\n\nSoftware Construct\n\n\nJinja2 Template Engine\n\n\nAVR toolchain: \navr-gcc\n and \navrdude\n\n\nARM toolchain: \narm-none-eabi-gcc\n and \nopenocd\n\n\n\n\nTo start actively developing on xpcc, you will also need these packages:\n\n\n\n\npython-lxml\n\n\ndoxygen\n\n\n\n\nInstalling on Linux\n#\n\n\nFor Ubuntu 14.04LTS, these commands install the basic build system:\n\n\nsudo apt-get install python python-jinja2 scons git\n\n\n\n\n\nInstall the AVR toochain:\n\n\nsudo apt-get install gcc-avr binutils-avr avr-libc avrdude\n\n\n\n\n\nAnd the ARM toolchain as well:\n\n\nsudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt-get update\nsudo apt-get install gcc-arm-embedded openocd\n\n\n\n\n\nTo compile programs for x86 systems install the following packets:\n\n\nsudo apt-get install gcc build-essential libboost-thread-dev \\\n                     libboost-system-dev libasio-dev\n\n\n\n\n\nFor active xpcc development install these packets too:\n\n\nsudo apt-get --no-install-recommends install doxygen\npip install --user lxml\n\n\n\n\n\nThis installs \ndoxygen\n without LaTeX support, which saves ~600MB of disk space.\n\n\nInstalling on OS X\n#\n\n\nFirst install \nhomebrew\n, a great packet\nmanager for OS X, then use it to install the minimum build system:\n\n\nbrew install python scons git\npip install --user jinja2\n\n\n\n\n\nInstall the AVR toochain:\n\n\nbrew tap larsimmisch/avr\nbrew install avr-libc avrdude\n\n\n\n\n\nAnd the ARM toolchain as well:\n\n\nbrew tap ARMmbed/homebrew-formulae\nbrew install arm-none-eabi-gcc\n\n\n\n\n\nTo program and debug your ARM Cortex-M device, you need to install the latest\n\nOpenOCD\n version:\n\n\nbrew install openocd --HEAD --enable-ft2232_libftdi \\\n                     --enable-jlink --enable-stlink\n\n\n\n\n\nFor active xpcc development install these packets too:\n\n\nbrew install doxygen\npip install --user lxml\n\n\n\n\n\nInstalling on Windows\n#\n\n\nWe're sorry, but since we do not have enough experience with Windows to provide\nhonest support, we recommend the use of our virtual machine.\n\nPull requests welcome!", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#virtual-machine", 
            "text": "If you just want to try out xpcc or do not want to install the build tools on\nyour machine just yet, we provide you with a  configured headless\nvirtual machine  running Ubuntu\n14.04LTS with all the build tools installed.  You only need to install  Virtualbox \nand  Vagrant  on your system, and can\nthen easily boot the VM and ssh into it:  git clone https://github.com/roboterclubaachen/xpcc.git cd  xpcc\nvagrant up\nvagrant ssh  Vagrant will download the virtual machine (~1.2GB), import it into VirtualBox\nand boot it, before logging into to it. There will be a shared folder located\nat  /vagrant  which contains the xpcc source code on your local file system.\nThis means you can use an editor of your choice to view and edit the source\ncode on you native OS, and then use the virtual machine to compile it.  So if you have an Arduino Uno lying around, you can then compile\nthe  LED blinking example :  cd  /vagrant/examples/arduino_uno/basic/blink/\nscons [ ... ] \nAVR Memory Usage\n----------------\nDevice: atmega328p\n\nProgram:      192  bytes  ( 0.6% used )  ( .data + .text ) \n\nData:           0  bytes  ( 0.0% used )  ( .bss + .data + .noinit )   You can compile every other example the same way.\nHere is the output of the STM32F4 Discovery Board  LED blinking example :  cd  /vagrant/examples/stm32f4_discovery/blink/\nscons [ ... ] \nMemory Usage\n------------\nDevice: stm32f407vg\n\nProgram:     1980  bytes  ( 0.2% used )  ( .data + .fastdata + .reset + .rodata + .text ) \n\nData:        3352  bytes  ( 1.7% used )   =   24  bytes static  ( 0.0% )  +  3328  bytes stack  ( 1.7% )  ( .bss + .data + .fastdata + .noinit + .stack ) \n\nHeap:      131060  bytes  ( 66.7% available )  ( .heap1 + .heap2 + .heap3 )   To program your board, just connect your board the the virtual machine and\ntype  scons program .\nHave a quick look at  the available build system commands  so you know what else you can do.", 
            "title": "Virtual machine"
        }, 
        {
            "location": "/installation/#native-installation", 
            "text": "Compiling the code in our virtual machine can be slower than compiling it\nnatively. To install the toolchain on your system, this is the\nminimum required software for the xpcc build system:   Python 2.7.x  Software Construct  Jinja2 Template Engine  AVR toolchain:  avr-gcc  and  avrdude  ARM toolchain:  arm-none-eabi-gcc  and  openocd   To start actively developing on xpcc, you will also need these packages:   python-lxml  doxygen", 
            "title": "Native installation"
        }, 
        {
            "location": "/installation/#installing-on-linux", 
            "text": "For Ubuntu 14.04LTS, these commands install the basic build system:  sudo apt-get install python python-jinja2 scons git  Install the AVR toochain:  sudo apt-get install gcc-avr binutils-avr avr-libc avrdude  And the ARM toolchain as well:  sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt-get update\nsudo apt-get install gcc-arm-embedded openocd  To compile programs for x86 systems install the following packets:  sudo apt-get install gcc build-essential libboost-thread-dev \\\n                     libboost-system-dev libasio-dev  For active xpcc development install these packets too:  sudo apt-get --no-install-recommends install doxygen\npip install --user lxml  This installs  doxygen  without LaTeX support, which saves ~600MB of disk space.", 
            "title": "Installing on Linux"
        }, 
        {
            "location": "/installation/#installing-on-os-x", 
            "text": "First install  homebrew , a great packet\nmanager for OS X, then use it to install the minimum build system:  brew install python scons git\npip install --user jinja2  Install the AVR toochain:  brew tap larsimmisch/avr\nbrew install avr-libc avrdude  And the ARM toolchain as well:  brew tap ARMmbed/homebrew-formulae\nbrew install arm-none-eabi-gcc  To program and debug your ARM Cortex-M device, you need to install the latest OpenOCD  version:  brew install openocd --HEAD --enable-ft2232_libftdi \\\n                     --enable-jlink --enable-stlink  For active xpcc development install these packets too:  brew install doxygen\npip install --user lxml", 
            "title": "Installing on OS X"
        }, 
        {
            "location": "/installation/#installing-on-windows", 
            "text": "We're sorry, but since we do not have enough experience with Windows to provide\nhonest support, we recommend the use of our virtual machine. Pull requests welcome!", 
            "title": "Installing on Windows"
        }, 
        {
            "location": "/guide/getting-started/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nGetting started\n#\n\n\nExamples\n#\n\n\nThe best way for you to quickly learn about xpcc's APIs is to look at and experiment with \nour examples\n, especially if you have a development board that xpcc \nsupports out-of-the-box\n.\nMake sure you have either our \nvirtual machine or the native toolchain installed\n.\n\n\nHere are our favorite examples for our supported development boards:\n\n\n\n\nArduino Uno:\n\nBlinky\n,\n\nButton \n Serial\n,\n\nAnalog \n Serial\n.\n\n\nNUCLEO-F103RB:\n\nBlinky \n Serial\n.\n\n\nSTM32F072 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nGyroscope\n.\n\n\nSTM32F3 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nAccelerometer\n,\n\nGyroscope\n,\n\nDebugging with GDB\n.\n\n\nSTM32F4 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nAccelerometer\n,\n\nTimer \n LED Animations\n,\n\nDebugging hard faults\n.\n\n\n\n\nHere are some additional examples of displays and sensors we like:\n\n\n\n\nSSD1306 OLED display\n: Draws text and graphics onto I2C display.\n\n\nBMP085/BMP180 barometer\n: Reads atmospheric pressure and temperature from I2C sensor.\n\n\nVL6180 time-of-flight distance sensor\n: Reads distance and ambient light from I2C sensor.\n\n\nTCS3414 color sensor\n: Reads RGB color from I2C sensor.\n\n\nHD44780 over I2C-GPIO expander\n: Draws text via native GPIO port or I2C-GPIO expander port onto character display.\n\n\n\n\nHave a look at \nthe build system commands\n to see how\nto compile and program your targets.\n\n\nYour own project\n#\n\n\nStart your own project by cloning \nour \ngetting-started\n project\n from GitHub:\n\n\ngit clone --recursive https://github.com/roboterclubaachen/getting-started-with-xpcc.git\n\ncd\n getting-started-with-xpcc\ntree\n.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 Vagrantfile\n\u251c\u2500\u2500 hello-world\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SConstruct\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 main.cpp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 project.cfg\n\u2514\u2500\u2500 xpcc \n(\ngit submodule\n)\n\n\n\n\n\n\nThe example contains the xpcc framework as a git submodule, a \nVagrantfile\n\nto enable use of \nour virtual machine\n,\na \nSConstruct\n file for \nour build system\n,\na project configuration file and of course the source code:\n\n\n#include\n \nxpcc/architecture/platform.hpp\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nBoard\n::\ninitialize\n();\n\n    \nBoard\n::\nLeds\n::\nsetOutput\n();\n\n\n    \nwhile\n \n(\n1\n)\n\n    \n{\n\n        \nBoard\n::\nLeds\n::\ntoggle\n();\n\n        \nxpcc\n::\ndelayMilliseconds\n(\nBoard\n::\nButton\n::\nread\n()\n \n?\n \n250\n \n:\n \n500\n);\n\n\n#ifdef XPCC_BOARD_HAS_LOGGER\n\n        \nstatic\n \nuint32_t\n \ncounter\n(\n0\n);\n\n        \nXPCC_LOG_INFO\n \n \nLoop counter: \n \n \n(\ncounter\n++\n)\n \n \nxpcc\n::\nendl\n;\n\n\n#endif\n\n    \n}\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nYou can change the development board for which you want to compile the example\nfor in the \nproject.cfg\n file:\n\n\n[build]\n\n\nboard\n \n=\n \nstm32f4_discovery\n\n\n#board = arduino_uno\n\n\n#board = nucleo_f103rb\n\n\n#board = stm32f072_discovery\n\n\n#board = stm32f1_discovery\n\n\n#board = stm32f3_discovery\n\n\n#board = stm32f429_discovery\n\n\n#board = stm32f469_discovery\n\n\n#board = stm32f7_discovery\n\n\n\n\n\n\nWhen you create you own project, you need to adapt the \nxpccpath\n inside the\n\nSConstruct\n to point to the location of the xpcc framework.\nNote that this allows you to use different versions of the xpcc frameworks\n(your own fork?) for your projects.\n\n\n# path to the xpcc root directory (modify as needed!)\n\n\nxpccpath\n \n=\n \n../xpcc\n\n\n# execute the common SConstruct file\n\n\nexecfile\n(\nxpccpath\n \n+\n \n/scons/SConstruct\n)\n\n\n\n\n\n\nShow me the basics\n#\n\n\nAll of this code works the same on all platforms, however, the pin and module\nnames may need to be adapted.\n\n\nGPIO\n#\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB0\n;\n\n\nLed\n::\nsetOutput\n();\n\n\nLed\n::\nset\n();\n    \n// 1 instruction on AVR\n\n\nLed\n::\nreset\n();\n  \n// 3 instructions on Cortex-M\n\n\nLed\n::\ntoggle\n();\n\n\n\nusing\n \nButton\n \n=\n \nGpioInputB0\n;\n\n\nButton\n::\nsetInput\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n\n\nbool\n \nstate\n \n=\n \nButton\n::\nread\n();\n\n\n\n\n\n\nBuffered UART\n#\n\n\nusing\n \nUart\n \n=\n \nUart0\n;\n\n\n// configure and initialize UART to 115.2kBaud\n\n\nGpioOutputD1\n::\nconnect\n(\nUart\n::\nTx\n);\n\n\nGpioInputD0\n::\nconnect\n(\nUart\n::\nRx\n);\n\n\nUart\n::\ninitialize\nsystemClock\n,\n \n115200\n();\n\n\n\nUart\n::\nwrite\n(\nH\n);\n  \n// Ohai there\n\n\nUart\n::\nwrite\n(\ni\n);\n\n\n\nuint8_t\n \nbuffer\n;\n\n\nwhile\n(\n1\n)\n \n{\n\n    \n// create a simple loopback\n\n    \nif\n \n(\nUart\n::\nread\n(\nbuffer\n))\n \n{\n\n        \nUart\n::\nwrite\n(\nbuffer\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIOStream\n#\n\n\nusing\n \nUart\n \n=\n \nUart0\n;\n\n\n// Create a IODevice with the Uart\n\n\nxpcc\n::\nIODeviceWrapper\nUart\n \ndevice\n;\n\n\nxpcc\n::\nIOStream\n \nstream\n(\ndevice\n);\n\n\n\nGpioOutputD1\n::\nconnect\n(\nUart\n::\nTx\n);\n\n\nUart\n::\ninitialize\nsystemClock\n,\n \n115200\n();\n\n\n\nstream\n \n \n42\n \n \n is a nice number!\n \n \nxpcc\n::\nendl\n;\n\n\n\n\n\n\nSoftware Timers\n#\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB0\n;\n\n\nxpcc\n::\nTimeout\n \ntimeout\n(\n10000\n);\n   \n// 10s timeout\n\n\nxpcc\n::\nPeriodicTimer\n \ntimer\n(\n250\n);\n \n// 250ms period\n\n\n\nLed\n::\nsetOutput\n(\nxpcc\n::\nGpio\n::\nHigh\n);\n\n\n\nwhile\n(\n1\n)\n \n{\n\n    \nif\n \n(\ntimeout\n.\nexecute\n())\n \n{\n\n        \ntimer\n.\nstop\n();\n\n        \nLed\n::\nreset\n();\n\n    \n}\n\n    \nif\n \n(\ntimer\n.\nexecute\n())\n \n{\n\n        \nLed\n::\ntoggle\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nHave a look at the \nxpcc/examples/\n folder\n for more advanced use cases.", 
            "title": "Getting started"
        }, 
        {
            "location": "/guide/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/guide/getting-started/#examples", 
            "text": "The best way for you to quickly learn about xpcc's APIs is to look at and experiment with  our examples , especially if you have a development board that xpcc  supports out-of-the-box .\nMake sure you have either our  virtual machine or the native toolchain installed .  Here are our favorite examples for our supported development boards:   Arduino Uno: Blinky , Button   Serial , Analog   Serial .  NUCLEO-F103RB: Blinky   Serial .  STM32F072 Discovery: Blinky , CAN , Gyroscope .  STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope , Debugging with GDB .  STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer   LED Animations , Debugging hard faults .   Here are some additional examples of displays and sensors we like:   SSD1306 OLED display : Draws text and graphics onto I2C display.  BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor.  VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor.  TCS3414 color sensor : Reads RGB color from I2C sensor.  HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display.   Have a look at  the build system commands  to see how\nto compile and program your targets.", 
            "title": "Examples"
        }, 
        {
            "location": "/guide/getting-started/#your-own-project", 
            "text": "Start your own project by cloning  our  getting-started  project  from GitHub:  git clone --recursive https://github.com/roboterclubaachen/getting-started-with-xpcc.git cd  getting-started-with-xpcc\ntree\n.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 Vagrantfile\n\u251c\u2500\u2500 hello-world\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SConstruct\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 main.cpp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 project.cfg\n\u2514\u2500\u2500 xpcc  ( git submodule )   The example contains the xpcc framework as a git submodule, a  Vagrantfile \nto enable use of  our virtual machine ,\na  SConstruct  file for  our build system ,\na project configuration file and of course the source code:  #include   xpcc/architecture/platform.hpp  int   main ()  { \n     Board :: initialize (); \n     Board :: Leds :: setOutput (); \n\n     while   ( 1 ) \n     { \n         Board :: Leds :: toggle (); \n         xpcc :: delayMilliseconds ( Board :: Button :: read ()   ?   250   :   500 );  #ifdef XPCC_BOARD_HAS_LOGGER \n         static   uint32_t   counter ( 0 ); \n         XPCC_LOG_INFO     Loop counter:      ( counter ++ )     xpcc :: endl ;  #endif \n     } \n     return   0 ;  }   You can change the development board for which you want to compile the example\nfor in the  project.cfg  file:  [build]  board   =   stm32f4_discovery  #board = arduino_uno  #board = nucleo_f103rb  #board = stm32f072_discovery  #board = stm32f1_discovery  #board = stm32f3_discovery  #board = stm32f429_discovery  #board = stm32f469_discovery  #board = stm32f7_discovery   When you create you own project, you need to adapt the  xpccpath  inside the SConstruct  to point to the location of the xpcc framework.\nNote that this allows you to use different versions of the xpcc frameworks\n(your own fork?) for your projects.  # path to the xpcc root directory (modify as needed!)  xpccpath   =   ../xpcc  # execute the common SConstruct file  execfile ( xpccpath   +   /scons/SConstruct )", 
            "title": "Your own project"
        }, 
        {
            "location": "/guide/getting-started/#show-me-the-basics", 
            "text": "All of this code works the same on all platforms, however, the pin and module\nnames may need to be adapted.", 
            "title": "Show me the basics"
        }, 
        {
            "location": "/guide/getting-started/#gpio", 
            "text": "using   Led   =   GpioOutputB0 ;  Led :: setOutput ();  Led :: set ();      // 1 instruction on AVR  Led :: reset ();    // 3 instructions on Cortex-M  Led :: toggle ();  using   Button   =   GpioInputB0 ;  Button :: setInput ( Gpio :: InputType :: PullUp );  bool   state   =   Button :: read ();", 
            "title": "GPIO"
        }, 
        {
            "location": "/guide/getting-started/#buffered-uart", 
            "text": "using   Uart   =   Uart0 ;  // configure and initialize UART to 115.2kBaud  GpioOutputD1 :: connect ( Uart :: Tx );  GpioInputD0 :: connect ( Uart :: Rx );  Uart :: initialize systemClock ,   115200 ();  Uart :: write ( H );    // Ohai there  Uart :: write ( i );  uint8_t   buffer ;  while ( 1 )   { \n     // create a simple loopback \n     if   ( Uart :: read ( buffer ))   { \n         Uart :: write ( buffer ); \n     }  }", 
            "title": "Buffered UART"
        }, 
        {
            "location": "/guide/getting-started/#iostream", 
            "text": "using   Uart   =   Uart0 ;  // Create a IODevice with the Uart  xpcc :: IODeviceWrapper Uart   device ;  xpcc :: IOStream   stream ( device );  GpioOutputD1 :: connect ( Uart :: Tx );  Uart :: initialize systemClock ,   115200 ();  stream     42      is a nice number!     xpcc :: endl ;", 
            "title": "IOStream"
        }, 
        {
            "location": "/guide/getting-started/#software-timers", 
            "text": "using   Led   =   GpioOutputB0 ;  xpcc :: Timeout   timeout ( 10000 );     // 10s timeout  xpcc :: PeriodicTimer   timer ( 250 );   // 250ms period  Led :: setOutput ( xpcc :: Gpio :: High );  while ( 1 )   { \n     if   ( timeout . execute ())   { \n         timer . stop (); \n         Led :: reset (); \n     } \n     if   ( timer . execute ())   { \n         Led :: toggle (); \n     }  }   Have a look at the  xpcc/examples/  folder  for more advanced use cases.", 
            "title": "Software Timers"
        }, 
        {
            "location": "/reference/api/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nAPI reference\n#\n\n\nxpcc is a relatively large framework with many APIs and advanced concepts.\nWe are annotating our APIs using Doxygen and are trying to provide conceptual\ndesign documentation on \nour project blog\n.\nHowever, this is a slow and difficult process, and the results are not perfect.\n\n\nThe most complete and most up-to-date API documentation is definitely the\n\n\n\n\nDoxygen API reference\n.\n\n\n\n\nUnfortunately the generated HAL for our many devices confuses Doxygen.\nWe therefore chose to only include the HAL API for \nATtiny85\n, the \nATmega328p\n\nand the \nSTM32F407vg\n online.\nThe rest of the xpcc API is documented without limitations.\n\n\n\n\n\nIf you are stuck, don't hesitate to \nsend us an email with your questions\n.", 
            "title": "API reference"
        }, 
        {
            "location": "/reference/api/#api-reference", 
            "text": "xpcc is a relatively large framework with many APIs and advanced concepts.\nWe are annotating our APIs using Doxygen and are trying to provide conceptual\ndesign documentation on  our project blog .\nHowever, this is a slow and difficult process, and the results are not perfect.  The most complete and most up-to-date API documentation is definitely the   Doxygen API reference .   Unfortunately the generated HAL for our many devices confuses Doxygen.\nWe therefore chose to only include the HAL API for  ATtiny85 , the  ATmega328p \nand the  STM32F407vg  online.\nThe rest of the xpcc API is documented without limitations.   If you are stuck, don't hesitate to  send us an email with your questions .", 
            "title": "API reference"
        }, 
        {
            "location": "/reference/build-system/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nBuild system\n#\n\n\nxpcc uses the \nSCons build system\n to generate, build and program your application.\nWe've extended it with many utilities to allow a smooth integration of embedded tools.\n\n\nBuild commands\n#\n\n\nYou can use these command in all our examples to get a feel of how it works.\n\n\nCommon\n#\n\n\n\n\nbuild\n: Generates the HAL and compiles your program into an executable.\n\n\nsize\n: Displays the static Flash and RAM consumption.\n\n\nprogram\n: Writes the executable onto your target.\n\n\n\n\n\nBy default \nscons\n executes \nscons build size\n.\n\n\n\n\nlisting\n: Decompiles your executable into an annotated assembly listing.\n\n\nsymbols\n: Displays the symbol table for your executable.\n\n\n-c\n: Cleans the project's build files.\n\n\nverbose=1\n: Makes the printout more verbose.\n\n\n\n\nAVR only:\n#\n\n\n\n\nfuse\n: Writes the fuse bits onto your target.\n\n\neeprom\n: Writes the EEPROM memory onto your target.\n\n\n\n\nARM Cortex-M only:\n#\n\n\n\n\ndebug\n: Starts the GDB debug session of your current application in text UI mode.\n\n           You must execute \nopenocd-debug\n or \nlpclink-debug\n before running this command!\n\n\nopenocd-debug\n: Starts the OpenOCD debug server for your target.\n\n\nlpclink-debug\n: Starts the LPC-Link debug server for your target.\n\n\nlpclink-init\n: Initialize the LPC-Link with its proprietary firmware.\n\n\n\n\nProject configuration\n#\n\n\nYour \nproject.cfg\n file contains configuration information for your target.\nFor the device identify naming scheme, see the \nDevice File reference\n.\n\n\n[build]\n\n\n# use a predefined board config file from xpcc/architecture/platform/board/\n\n\n# it defines the configuration for a board, which you can overwrite here.\n\n\nboard\n \n=\n \nstm32f4_discovery\n\n\n\n# declare the name of your project. Default is enclosing folder name.\n\n\nname\n \n=\n \nblinky\n\n\n# the target of your project, use the full name of the device here\n\n\ndevice\n \n=\n \nstm32f407vg\n\n\n# AVR only: declare the clock frequency in Hz\n\n\nclock\n \n=\n \n16000000\n\n\n# overwrite the default `./build/` folder path\n\n\nbuildpath\n \n=\n \n../../build/${name}\n\n\n\n# parametrize HAL drivers here, see section on Parameters\n\n\n[parameters]\n\n\nuart.stm32.3.tx_buffer\n \n=\n \n2048\n\n\nuart.stm32.3.rx_buffer\n \n=\n \n256\n\n\n\n# AVR only: declare fuse bits for use with  $ scons fuse\n\n\n[fusebits]\n\n\n# only the fuses declared here are written\n\n\nefuse\n \n=\n \n0x41\n\n\nhfuse\n \n=\n \n0x42\n\n\nlfuse\n \n=\n \n0x43\n\n\n\n# AVR only: configure avrdude for  $ scons program\n\n\n# Consult the avrdude documentation for options.\n\n\n[avrdude]\n\n\n# using the AVR ISP mk2 programmer\n\n\nport\n \n=\n \nusb\n\n\nprogrammer\n \n=\n \navrispmkII\n\n\n# or using a serial bootloader\n\n\nport\n \n=\n \n/dev/ttyUSB0\n\n\nprogrammer\n \n=\n \narduino\n\n\n# baudrate only required for serial bootloaders\n\n\nbaudrate\n \n=\n \n115200\n\n\n\n# ARM only: configure OpenOCD for  $ scons program\n\n\n[openocd]\n\n\n# OpenOCD has predefined configs in its searchpaths\n\n\nconfigfile\n \n=\n \nboard/stm32f4discovery.cfg\n\n\n# but you can also use your own special config file\n\n\nconfigfile\n \n=\n \nopenocd.cfg\n\n\n# the commands to run on  $ scons program. Defaults are:\n\n\ncommands\n \n=\n\n\n    init\n\n\n    reset halt\n\n\n    flash write_image erase $SOURCE\n\n\n    reset run\n\n\n    shutdown\n\n\n\n# LPC targets with LPC-Linkv2 programmer only\n\n\n[lpclink]\n\n\n# base path of the lpcxpresso installation\n\n\n# Default on Linux: /opt/lpcxpresso/\n\n\n# Default on OS X: /Applications/lcpxpresso_*/ (first match)\n\n\nbasepath\n \n=\n \n../lpcxpresso\n\n\n\n\n\n\nParameters\n#\n\n\nIn order to customize drivers further, driver parameters may be declared.\nThese follow the naming scheme \ntype.name.instance.parameter\n and are restrictive in the values they accept. Here is an overview of the available parameters.\n\n\nSet the software queue size for CAN messages for peripheral instance \nN\n in addition to the hardware queues:\n\n\n\n\ncan.stm32.N.tx_buffer \u2208 [0,254] = 32\n\n\ncan.stm32.N.rx_buffer \u2208 [0,254] = 32\n\n\n\n\nSets the main stack size. Note that the linkerscript may increase this to satisfy alignment requirements, especially with the vector table mapped to RAM. Default size is \n3kB - 32B\n.\n\n\n\n\ncore.cortex.0.main_stack_size \u2208 [512, 8192] = 3040\n\n\n\n\nPlaces the vector table in RAM. When your stack and interrupt vector table reside in the same RAM section, this will decrease interrupt response time! The default setting is the fastest setting.\n\n\n\n\ncore.cortex.0.vector_table_in_ram \u2208 bool = false (true on STM32F3/STM32F7)\n\n\n\n\nEnables the blinking LED inside the hard fault handler.\nUse this feature to easily identify a crashed processor!\n\n\n\n\ncore.cortex.0.enable_hardfault_handler_led \u2208 bool = false\n\n\ncore.cortex.0.hardfault_handler_led_port \u2208 {A,B,C,D,E,F,G,H,I,J,K}\n\n\ncore.cortex.0.hardfault_handler_led_pin \u2208 [0,15]\n\n\n\n\nEnables the serial logger inside the hard fault handler.\nUse \nbasic\n for a minimal failure trace or \ntrue\n for a complete trace.\nYou must provide the peripheral instance of the used serial port as well as a \nXPCC_LOG_ERROR\n output stream!\n\n\n\n\ncore.cortex.0.enable_hardfault_handler_log \u2208 {false,basic,true} = false\n\n\ncore.cortex.0.hardfault_handler_uart \u2208 [1,8]\n\n\n\n\nSets the size of the transaction buffer for peripheral instance \nN\n.\nIncrease this if you have many connected I2C slaves.\n\n\n\n\ni2c.stm32.N.transaction_buffer \u2208 [1,100] = 8\n\n\n\n\nForces the SPI driver on AVRs to poll for transfer completion rather than to delegate execution back to the main loop. Enabling this only makes sense for very high SPI frequencies.\n\n\n\n\nspi.at90_tiny_mega.0.busywait \u2208 bool = false\n\n\n\n\nSet the software buffer for UART data for peripheral instance \nN\n.\nThe size is limited on AVRs, due to atomicity requirements!\n\n\n\n\nuart.at90_tiny_mega.N.tx_buffer \u2208 [1,254] = 64\n\n\n\n\nuart.at90_tiny_mega.N.rx_buffer \u2208 [1,254] = 8\n\n\n\n\n\n\nuart.lpc.0.tx_buffer \u2208 [1,65534] = 250\n\n\n\n\n\n\nuart.lpc.0.rx_buffer \u2208 [1,65534] = 16\n\n\n\n\n\n\nuart.stm32.N.tx_buffer \u2208 [1,65534] = 250\n\n\n\n\nuart.stm32.N.rx_buffer \u2208 [1,65534] = 16", 
            "title": "Build system"
        }, 
        {
            "location": "/reference/build-system/#build-system", 
            "text": "xpcc uses the  SCons build system  to generate, build and program your application.\nWe've extended it with many utilities to allow a smooth integration of embedded tools.", 
            "title": "Build system"
        }, 
        {
            "location": "/reference/build-system/#build-commands", 
            "text": "You can use these command in all our examples to get a feel of how it works.", 
            "title": "Build commands"
        }, 
        {
            "location": "/reference/build-system/#common", 
            "text": "build : Generates the HAL and compiles your program into an executable.  size : Displays the static Flash and RAM consumption.  program : Writes the executable onto your target.   By default  scons  executes  scons build size .   listing : Decompiles your executable into an annotated assembly listing.  symbols : Displays the symbol table for your executable.  -c : Cleans the project's build files.  verbose=1 : Makes the printout more verbose.", 
            "title": "Common"
        }, 
        {
            "location": "/reference/build-system/#avr-only", 
            "text": "fuse : Writes the fuse bits onto your target.  eeprom : Writes the EEPROM memory onto your target.", 
            "title": "AVR only:"
        }, 
        {
            "location": "/reference/build-system/#arm-cortex-m-only", 
            "text": "debug : Starts the GDB debug session of your current application in text UI mode. \n           You must execute  openocd-debug  or  lpclink-debug  before running this command!  openocd-debug : Starts the OpenOCD debug server for your target.  lpclink-debug : Starts the LPC-Link debug server for your target.  lpclink-init : Initialize the LPC-Link with its proprietary firmware.", 
            "title": "ARM Cortex-M only:"
        }, 
        {
            "location": "/reference/build-system/#project-configuration", 
            "text": "Your  project.cfg  file contains configuration information for your target.\nFor the device identify naming scheme, see the  Device File reference .  [build]  # use a predefined board config file from xpcc/architecture/platform/board/  # it defines the configuration for a board, which you can overwrite here.  board   =   stm32f4_discovery  # declare the name of your project. Default is enclosing folder name.  name   =   blinky  # the target of your project, use the full name of the device here  device   =   stm32f407vg  # AVR only: declare the clock frequency in Hz  clock   =   16000000  # overwrite the default `./build/` folder path  buildpath   =   ../../build/${name}  # parametrize HAL drivers here, see section on Parameters  [parameters]  uart.stm32.3.tx_buffer   =   2048  uart.stm32.3.rx_buffer   =   256  # AVR only: declare fuse bits for use with  $ scons fuse  [fusebits]  # only the fuses declared here are written  efuse   =   0x41  hfuse   =   0x42  lfuse   =   0x43  # AVR only: configure avrdude for  $ scons program  # Consult the avrdude documentation for options.  [avrdude]  # using the AVR ISP mk2 programmer  port   =   usb  programmer   =   avrispmkII  # or using a serial bootloader  port   =   /dev/ttyUSB0  programmer   =   arduino  # baudrate only required for serial bootloaders  baudrate   =   115200  # ARM only: configure OpenOCD for  $ scons program  [openocd]  # OpenOCD has predefined configs in its searchpaths  configfile   =   board/stm32f4discovery.cfg  # but you can also use your own special config file  configfile   =   openocd.cfg  # the commands to run on  $ scons program. Defaults are:  commands   =      init      reset halt      flash write_image erase $SOURCE      reset run      shutdown  # LPC targets with LPC-Linkv2 programmer only  [lpclink]  # base path of the lpcxpresso installation  # Default on Linux: /opt/lpcxpresso/  # Default on OS X: /Applications/lcpxpresso_*/ (first match)  basepath   =   ../lpcxpresso", 
            "title": "Project configuration"
        }, 
        {
            "location": "/reference/build-system/#parameters", 
            "text": "In order to customize drivers further, driver parameters may be declared.\nThese follow the naming scheme  type.name.instance.parameter  and are restrictive in the values they accept. Here is an overview of the available parameters.  Set the software queue size for CAN messages for peripheral instance  N  in addition to the hardware queues:   can.stm32.N.tx_buffer \u2208 [0,254] = 32  can.stm32.N.rx_buffer \u2208 [0,254] = 32   Sets the main stack size. Note that the linkerscript may increase this to satisfy alignment requirements, especially with the vector table mapped to RAM. Default size is  3kB - 32B .   core.cortex.0.main_stack_size \u2208 [512, 8192] = 3040   Places the vector table in RAM. When your stack and interrupt vector table reside in the same RAM section, this will decrease interrupt response time! The default setting is the fastest setting.   core.cortex.0.vector_table_in_ram \u2208 bool = false (true on STM32F3/STM32F7)   Enables the blinking LED inside the hard fault handler.\nUse this feature to easily identify a crashed processor!   core.cortex.0.enable_hardfault_handler_led \u2208 bool = false  core.cortex.0.hardfault_handler_led_port \u2208 {A,B,C,D,E,F,G,H,I,J,K}  core.cortex.0.hardfault_handler_led_pin \u2208 [0,15]   Enables the serial logger inside the hard fault handler.\nUse  basic  for a minimal failure trace or  true  for a complete trace.\nYou must provide the peripheral instance of the used serial port as well as a  XPCC_LOG_ERROR  output stream!   core.cortex.0.enable_hardfault_handler_log \u2208 {false,basic,true} = false  core.cortex.0.hardfault_handler_uart \u2208 [1,8]   Sets the size of the transaction buffer for peripheral instance  N .\nIncrease this if you have many connected I2C slaves.   i2c.stm32.N.transaction_buffer \u2208 [1,100] = 8   Forces the SPI driver on AVRs to poll for transfer completion rather than to delegate execution back to the main loop. Enabling this only makes sense for very high SPI frequencies.   spi.at90_tiny_mega.0.busywait \u2208 bool = false   Set the software buffer for UART data for peripheral instance  N .\nThe size is limited on AVRs, due to atomicity requirements!   uart.at90_tiny_mega.N.tx_buffer \u2208 [1,254] = 64   uart.at90_tiny_mega.N.rx_buffer \u2208 [1,254] = 8    uart.lpc.0.tx_buffer \u2208 [1,65534] = 250    uart.lpc.0.rx_buffer \u2208 [1,65534] = 16    uart.stm32.N.tx_buffer \u2208 [1,65534] = 250   uart.stm32.N.rx_buffer \u2208 [1,65534] = 16", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/device-files/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;}.md\nDevice Files\n#\n\n\nThe device file describes the device metadata and peripheral tree in XML.\nInformation from one device can be extracted by providing the device identifier.\n\n\nDevice Identifier\n#\n\n\nThe device identifier is the canonical representation of the device name within the device file.\nIt consists out of the following elements with examples for device names \nstm32f407vg\n and \natmega328p\n:\n\n\n\n\n\n\n\n\nElement\n\n\nSTM32\n\n\nAVR\n\n\n\n\n\n\n\n\n\n\nplatform\n\n\nstm32\n\n\navr\n\n\n\n\n\n\nfamily\n\n\nf4\n\n\natmega\n\n\n\n\n\n\nname\n\n\n407\n\n\n328\n\n\n\n\n\n\ntype\n\n\n\n\np\n\n\n\n\n\n\npin-id\n\n\nv\n\n\n\n\n\n\n\n\nsize-id\n\n\ng\n\n\n32\n\n\n\n\n\n\n\n\nNotice that type and pin-id have different interpretations on the STM32 and AVR platform, which reflects in the device file format.\n\n\nNaming Scheme\n#\n\n\nAll device files can be currently found in the \nxpcc/architecture/platform/devices/\n, with the naming schemes dependend on architecture.\nExamples include:\n\n\n\n\navr:\n\n\nAT90: \nat90\n + \nsizes-type\n\n\nat9032_64_128-can.xml\n for \nAT90CAN(32|64|128)\n\n\n\n\n\n\nATtiny, ATmega: \natmega\n + \nsizes-types\n\n\natmega48_88_168_328-a_none_p_pa.xml\n for \nATMEGA(48|88|169|328)(a|p|pa)?\n\n\n\n\n\n\nATxmega: \nxmega\n + \nsizes-package-types\n\n\nxmega64_128-a1-none_u.xml\n for \nATXMEGA(64|128)A1(U)?\n\n\n\n\n\n\n\n\n\n\nstm32:\n\n\nSTM32F: \nstm32f\n + \nnames-pins-sizes\n\n\nstm32f405_407_415_417-i_r_v_z-e_g.xml\n for \nSTM32F(405|407|415|417)(I|R|V|Z)(E|G)\n\n\n\n\n\n\n\n\n\n\n\n\nFile Format\n#\n\n\nThe device files encode information about one or several very similar devices using a tree representation.\nThe device tree root declares its device scope using OR'ed device identifier elements.\n\n\nHere is the \nATmega328\n device family as an example:\n\n\ndevice\n \nplatform=\navr\n \nfamily=\natmega\n \nname=\n48|88|168|328\n \nsize_id=\n4|8|16|32\n \ntype=\na|none|p|pa\n\n  ...\n\n/device\n\n\n\n\n\n\nThis looks very similar for the \nSTM32F407\n device family:\n\n\ndevice\n \nplatform=\nstm32\n \nfamily=\nf4\n \nname=\n405|407|415|417\n \npin_id=\ni|r|v|z\n \nsize_id=\ne|g\n\n  ...\n\n/device\n\n\n\n\n\n\nAvailable Elements\n#\n\n\nInside the device tag, the following elements describe the device:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nflash\n\n\nsize of available non-volatile memory in bytes\n\n\n\n\n\n\nram\n\n\nsize of available volatile memory in bytes\n\n\n\n\n\n\neeprom\n\n\nsize of available eeprom in bytes (avr-only)\n\n\n\n\n\n\nlinkerscript\n\n\nname of linkerscript (cortex-m-only)\n\n\n\n\n\n\ncore\n\n\nname of CPU core\n\n\n\n\n\n\nmcu\n\n\navrdude name of device (avr-only)\n\n\n\n\n\n\npin-count\n\n\nnumber of pins on device\n\n\n\n\n\n\nheader\n\n\nrequired device header(s)\n\n\n\n\n\n\ndefine\n\n\nrequired device define(s)\n\n\n\n\n\n\ndriver\n\n\na peripheral driver implementation\n\n\n\n\n\n\n\n\nFor example, all devices in the STM32F407 family have 192kB of RAM:\n\n\nram\n196608\n/ram\n\n\n\n\n\n\nHowever, each element may also declare its device scope by including device identifier attributes.\nTo distinguish filterable device identifier attributes from declaration attributes, they must be prefixed with \ndevice-\n.\n\n\nFor the ATmega328 family several RAM sizes exist depending on device name:\n\n\nram\n \ndevice-name=\n48\n512\n/ram\n\n\nram\n \ndevice-name=\n88|168\n1024\n/ram\n\n\nram\n \ndevice-name=\n328\n2048\n/ram\n\n\n\n\n\n\nYou are even able to use the value of these elements to further limit the scope of new elements.\n\n\nAn example of this can be seen in the core driver file (discussed later), which uses the core element as device-scope:\n\n\ntemplate\n \ncore=\ncortex-m3|cortex-m4|cortex-m4f\nhard_fault_handler.cpp.in\n/template\n\n\n\n\n\n\nAs the device file is declarative, the filtering engine will resolve all dependencies recursively and throw an error in case of unresolved elements or circular referencing.\n\n\nAvailable Drivers\n#\n\n\nThe driver elements link the device hardware peripheral with a software implementation, which are found in \nxpcc/architecture/platform/driver/\n.\nEach driver is divided into several hardware dependend implementations.\n\n\nA selection of the most important drivers are:\n\n\ndriver\n|-- adc\n|-- can\n|-- clock\n|-- fsmc\n|-- gpio\n|   |-- at90_tiny_mega\n|   |-- generic\n|   `-- stm32\n|-- i2c\n|-- spi\n|   |-- at90_tiny_mega\n|   |-- at90_tiny_mega_uart\n|   |-- generic\n|   |-- stm32\n|   `-- stm32_uart\n|-- timer\n`-- uart\n\n\n\n\n\nNotice the \ngeneric\n folders. These are available for all platforms and are automatically included.\n\n\nAlso, notice how there exist two implementations for \nspi\n for the \nstm32\n and \nat90_tiny_mega\n platform.\nOne is for using the dedicated SPI hardware, and the other is for the UART hardware in SPI mode, however, both conform to the same SPI interface:\n\n\ndriver\n \ntype=\nspi\n \nname=\nstm32\n \ninstances=\n1,2,3\n/\n\n\ndriver\n \ntype=\nspi\n \nname=\nstm32_uart\n \ninstances=\n1,2,3,4,5,6\n/\n\n\n\n\n\n\nOf course, drivers may also declare device scope. For the STM32F407 family, the FSMC is not available for pin-id \nR\n (=64 pins):\n\n\ndriver\n \ndevice-pin-id=\ni|v|z\n \ntype=\nfsmc\n \nname=\nstm32\n/\n\n\n\n\n\n\nAny childen of a driver element will be available inside the driver instance template. Except for the reserved name \nparameter\n, there are no limitations on data structure or naming.\n\n\nFor example, the GPIO driver needs to know which pins are available for the requested device (with the \ngpio\n element), and what alternate functions to connect to them (with the \naf\n element).\n\n\nThis information is encoded as driver element children (here for the ATmega328 device family):\n\n\ndriver\n \ntype=\ngpio\n \nname=\nat90_tiny_mega\n\n  \ngpio\n \nport=\nB\n \nid=\n0\n \npcint=\n0\n/\n\n  ...\n  \ngpio\n \nport=\nD\n \nid=\n1\n \npcint=\n17\n\n    \naf\n \nperipheral=\nUart0\n \ntype=\nout\n \nname=\nTxd\n/\n\n  \n/gpio\n\n  \ngpio\n \nport=\nD\n \nid=\n2\n \npcint=\n18\n \nextint=\n0\n/\n\n  ...\n\n/driver\n\n\n\n\n\n\nOf course, device scope may also be declared for individual pins and even alternate functions (here for the STM32F407 device family):\n\n\ndriver\n \ntype=\ngpio\n \nname=\nstm32\n\n  ...\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n1\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nNbl1\n/\n\n  \n/gpio\n\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n2\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nA23\n/\n\n  \n/gpio\n\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n3\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nA19\n/\n\n  \n/gpio\n\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n4\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nA20\n/\n\n  \n/gpio\n\n  ...\n\n/driver\n\n\n\n\n\n\nThis structure is then available as a dictionary inside the device driver template files.\n\n\nDriver Files\n#\n\n\nThe device file only describes which folder contains the driver implementation and metadata for its implementation.\nIt does not specify which files are part of the implementation, and how multiple instances of a driver are created.\n\n\nThis is done using the \ndriver.xml\n file inside each driver implemenation.\nFor the \nat90_tiny_mega\n GPIO driver it contains:\n\n\ndriver\n \ntype=\ngpio\n \nname=\nat90_tiny_mega\n\n    \nstatic\ngpio_define.h\n/static\n\n    \ntemplate\ngpio.hpp.in\n/template\n\n    ...\n\n/driver\n\n\n\n\n\n\nHere the elements stand for:\n\n\n\n\nstatic\n: copy source file without modification,\n\n\ntemplate\n: generate source file \ngpio.hpp\n from \ngpio.hpp.in\n template with the device file GPIO data\n\n\n\n\nLet's look at how to generate several driver instances using a driver file.\nHere is the \nat90_tiny_meta\n UART driver file:\n\n\ndriver\n \ntype=\nuart\n \nname=\nat90_tiny_mega\n\n    \ntemplate\n \ninstances=\n0,1,2,3\n \nout=\nuart{{id}}.hpp\nuart.hpp.in\n/template\n\n    ...\n\n/driver\n\n\n\n\n\n\nHere the driver file has the capability to generate the instances 0,1,2 and 3 of the UART classes, and write them into the format specified by the \nout\n attribute.\nThe \ninstances\n attribute can be used to generate different instances out of different template files as shown in the \nstm32\n UART driver file:\n\n\ndriver\n \ntype=\nuart\n \nname=\nstm32\n\n    \ntemplate\n \ninstances=\n1,2,3,6\n \nout=\nusart_{{id}}.hpp\nuart.hpp.in\n/template\n\n    \ntemplate\n \ninstances=\n4,5\n \nout=\nuart_{{id}}.hpp\nuart.hpp.in\n/template\n\n    ...\n\n/driver\n\n\n\n\n\n\nNote, that only the instances declared in the device file will actually be generated!\n\n\nSo for the ATmega328, only UART instance 0 will be generated, since that has been declared in the device file:\n\n\ndriver\n \ntype=\nuart\n \nname=\nat90_tiny_mega\n \ninstances=\n0\n/\n\n\n\n\n\n\nCustom elements\n#\n\n\nIn the driver file, custom device-scoped elements may be declared, as in the \nat90_tiny_mega\n GPIO driver file:\n\n\ndriver\n \ntype=\ngpio\n \nname=\nat90_tiny_mega\n\n    ...\n    \nnotoggle\n \ndevice-family=\natmega\n \ndevice-name=\n8|16|32|64|128|162|8515|8535\nTrue\n/notoggle\n\n    \nnotoggle\n \ndevice-family=\nattiny\n \ndevice-name=\n26\nTrue\n/notoggle\n\n    ...\n\n/driver\n\n\n\n\n\n\nHere the \nnotoggle\n element will be added to the substitution dictionary only for the specified devices.\n\n\nParameters\n#\n\n\nIn order to customize drivers further parameters may be declared.\nThere are currently three types available:\n\n\n\n\nint\n: has a minimum and a maximum value\n\n\nbool\n: true/false\n\n\nenum\n: semicolon-separated values\n\n\n\n\nAll buffered UART implementations have two parameters named \ntx_buffer\n and \nrx_buffer\n, which are of type \nint\n and set the size of the atomic transmit and receive buffer.\n\n\ndriver\n \ntype=\nuart\n \nname=\nat90_tiny_mega\n\n    ...\n    \nparameter\n \nname=\ntx_buffer\n \ntype=\nint\n \nmin=\n1\n \nmax=\n254\n8\n/parameter\n\n    \nparameter\n \nname=\nrx_buffer\n \ntype=\nint\n \nmin=\n1\n \nmax=\n254\n4\n/parameter\n\n\n/driver\n\n\n\n\n\n\nEach UART instance receives their own two independent parameters with these default values.\n\n\nThe \nstm32\n core driver features the other two types:\n\n\ndriver\n \ntype=\ncore\n \nname=\ncortex\n\n    \nparameter\n \nname=\nallocator\n \ntype=\nenum\n \nvalues=\nnewlib;block_allocator\n\n        block_allocator\n    \n/parameter\n\n    \nparameter\n \nname=\nenable_gpio\n \ntype=\nbool\ntrue\n/parameter\n\n    ...\n\n/driver\n\n\n\n\n\n\nThese parameter may be overwritten in either the device file, or in the \nproject.cfg\n in the section \n[parameters]\n, which follows the naming scheme \ntype.name.instance.parameter\n:\n\n\n[\nparameters\n]\n\n\nuart\n.\nat90_tiny_mega\n.\n0.\ntx_buffer\n \n=\n \n200\n\n\nuart\n.\nat90_tiny_mega\n.\n0.\nrx_buffer\n \n=\n \n100\n\n\n\n\n\n\nGenerator\n#\n\n\nWe designed the device file format to use this form of XML to not only be human readable, but much more important, to be human-writeable.\n\n\nWe decided to group multiple devices of the same functionality family into one device file, instead of providing one device file for each of these devices.\n\n\nThis made accessing the devices files computationally more complex, since we have to evaluate the device-scope, however, it dramatically reduces redundancies and allows a much more natural description of devices in this language.\n\n\nWhile the first device files were still written manually, a device file generator soon became necessary to allow inclusion of many devices and to help with refactoring during API changes.\n\n\nThis generator uses multiple manufacturer provided description files to extract data about multiple devices and compress them into one device file, while preserving readability and correctness.\n\n\nFurther information about the device file generator can be found in the Readme at \n/tools/device_file_generator\n.", 
            "title": "Device files"
        }, 
        {
            "location": "/reference/device-files/#device-files", 
            "text": "The device file describes the device metadata and peripheral tree in XML.\nInformation from one device can be extracted by providing the device identifier.", 
            "title": "Device Files"
        }, 
        {
            "location": "/reference/device-files/#device-identifier", 
            "text": "The device identifier is the canonical representation of the device name within the device file.\nIt consists out of the following elements with examples for device names  stm32f407vg  and  atmega328p :     Element  STM32  AVR      platform  stm32  avr    family  f4  atmega    name  407  328    type   p    pin-id  v     size-id  g  32     Notice that type and pin-id have different interpretations on the STM32 and AVR platform, which reflects in the device file format.", 
            "title": "Device Identifier"
        }, 
        {
            "location": "/reference/device-files/#naming-scheme", 
            "text": "All device files can be currently found in the  xpcc/architecture/platform/devices/ , with the naming schemes dependend on architecture.\nExamples include:   avr:  AT90:  at90  +  sizes-type  at9032_64_128-can.xml  for  AT90CAN(32|64|128)    ATtiny, ATmega:  atmega  +  sizes-types  atmega48_88_168_328-a_none_p_pa.xml  for  ATMEGA(48|88|169|328)(a|p|pa)?    ATxmega:  xmega  +  sizes-package-types  xmega64_128-a1-none_u.xml  for  ATXMEGA(64|128)A1(U)?      stm32:  STM32F:  stm32f  +  names-pins-sizes  stm32f405_407_415_417-i_r_v_z-e_g.xml  for  STM32F(405|407|415|417)(I|R|V|Z)(E|G)", 
            "title": "Naming Scheme"
        }, 
        {
            "location": "/reference/device-files/#file-format", 
            "text": "The device files encode information about one or several very similar devices using a tree representation.\nThe device tree root declares its device scope using OR'ed device identifier elements.  Here is the  ATmega328  device family as an example:  device   platform= avr   family= atmega   name= 48|88|168|328   size_id= 4|8|16|32   type= a|none|p|pa \n  ... /device   This looks very similar for the  STM32F407  device family:  device   platform= stm32   family= f4   name= 405|407|415|417   pin_id= i|r|v|z   size_id= e|g \n  ... /device", 
            "title": "File Format"
        }, 
        {
            "location": "/reference/device-files/#available-elements", 
            "text": "Inside the device tag, the following elements describe the device:     Element  Description      flash  size of available non-volatile memory in bytes    ram  size of available volatile memory in bytes    eeprom  size of available eeprom in bytes (avr-only)    linkerscript  name of linkerscript (cortex-m-only)    core  name of CPU core    mcu  avrdude name of device (avr-only)    pin-count  number of pins on device    header  required device header(s)    define  required device define(s)    driver  a peripheral driver implementation     For example, all devices in the STM32F407 family have 192kB of RAM:  ram 196608 /ram   However, each element may also declare its device scope by including device identifier attributes.\nTo distinguish filterable device identifier attributes from declaration attributes, they must be prefixed with  device- .  For the ATmega328 family several RAM sizes exist depending on device name:  ram   device-name= 48 512 /ram  ram   device-name= 88|168 1024 /ram  ram   device-name= 328 2048 /ram   You are even able to use the value of these elements to further limit the scope of new elements.  An example of this can be seen in the core driver file (discussed later), which uses the core element as device-scope:  template   core= cortex-m3|cortex-m4|cortex-m4f hard_fault_handler.cpp.in /template   As the device file is declarative, the filtering engine will resolve all dependencies recursively and throw an error in case of unresolved elements or circular referencing.", 
            "title": "Available Elements"
        }, 
        {
            "location": "/reference/device-files/#available-drivers", 
            "text": "The driver elements link the device hardware peripheral with a software implementation, which are found in  xpcc/architecture/platform/driver/ .\nEach driver is divided into several hardware dependend implementations.  A selection of the most important drivers are:  driver\n|-- adc\n|-- can\n|-- clock\n|-- fsmc\n|-- gpio\n|   |-- at90_tiny_mega\n|   |-- generic\n|   `-- stm32\n|-- i2c\n|-- spi\n|   |-- at90_tiny_mega\n|   |-- at90_tiny_mega_uart\n|   |-- generic\n|   |-- stm32\n|   `-- stm32_uart\n|-- timer\n`-- uart  Notice the  generic  folders. These are available for all platforms and are automatically included.  Also, notice how there exist two implementations for  spi  for the  stm32  and  at90_tiny_mega  platform.\nOne is for using the dedicated SPI hardware, and the other is for the UART hardware in SPI mode, however, both conform to the same SPI interface:  driver   type= spi   name= stm32   instances= 1,2,3 /  driver   type= spi   name= stm32_uart   instances= 1,2,3,4,5,6 /   Of course, drivers may also declare device scope. For the STM32F407 family, the FSMC is not available for pin-id  R  (=64 pins):  driver   device-pin-id= i|v|z   type= fsmc   name= stm32 /   Any childen of a driver element will be available inside the driver instance template. Except for the reserved name  parameter , there are no limitations on data structure or naming.  For example, the GPIO driver needs to know which pins are available for the requested device (with the  gpio  element), and what alternate functions to connect to them (with the  af  element).  This information is encoded as driver element children (here for the ATmega328 device family):  driver   type= gpio   name= at90_tiny_mega \n   gpio   port= B   id= 0   pcint= 0 / \n  ...\n   gpio   port= D   id= 1   pcint= 17 \n     af   peripheral= Uart0   type= out   name= Txd / \n   /gpio \n   gpio   port= D   id= 2   pcint= 18   extint= 0 / \n  ... /driver   Of course, device scope may also be declared for individual pins and even alternate functions (here for the STM32F407 device family):  driver   type= gpio   name= stm32 \n  ...\n   gpio   device-pin-id= i|v|z   port= E   id= 1 \n     af   id= 12   peripheral= Fsmc   name= Nbl1 / \n   /gpio \n   gpio   device-pin-id= i|v|z   port= E   id= 2 \n     af   id= 12   peripheral= Fsmc   name= A23 / \n   /gpio \n   gpio   device-pin-id= i|v|z   port= E   id= 3 \n     af   id= 12   peripheral= Fsmc   name= A19 / \n   /gpio \n   gpio   device-pin-id= i|v|z   port= E   id= 4 \n     af   id= 12   peripheral= Fsmc   name= A20 / \n   /gpio \n  ... /driver   This structure is then available as a dictionary inside the device driver template files.", 
            "title": "Available Drivers"
        }, 
        {
            "location": "/reference/device-files/#driver-files", 
            "text": "The device file only describes which folder contains the driver implementation and metadata for its implementation.\nIt does not specify which files are part of the implementation, and how multiple instances of a driver are created.  This is done using the  driver.xml  file inside each driver implemenation.\nFor the  at90_tiny_mega  GPIO driver it contains:  driver   type= gpio   name= at90_tiny_mega \n     static gpio_define.h /static \n     template gpio.hpp.in /template \n    ... /driver   Here the elements stand for:   static : copy source file without modification,  template : generate source file  gpio.hpp  from  gpio.hpp.in  template with the device file GPIO data   Let's look at how to generate several driver instances using a driver file.\nHere is the  at90_tiny_meta  UART driver file:  driver   type= uart   name= at90_tiny_mega \n     template   instances= 0,1,2,3   out= uart{{id}}.hpp uart.hpp.in /template \n    ... /driver   Here the driver file has the capability to generate the instances 0,1,2 and 3 of the UART classes, and write them into the format specified by the  out  attribute.\nThe  instances  attribute can be used to generate different instances out of different template files as shown in the  stm32  UART driver file:  driver   type= uart   name= stm32 \n     template   instances= 1,2,3,6   out= usart_{{id}}.hpp uart.hpp.in /template \n     template   instances= 4,5   out= uart_{{id}}.hpp uart.hpp.in /template \n    ... /driver   Note, that only the instances declared in the device file will actually be generated!  So for the ATmega328, only UART instance 0 will be generated, since that has been declared in the device file:  driver   type= uart   name= at90_tiny_mega   instances= 0 /", 
            "title": "Driver Files"
        }, 
        {
            "location": "/reference/device-files/#custom-elements", 
            "text": "In the driver file, custom device-scoped elements may be declared, as in the  at90_tiny_mega  GPIO driver file:  driver   type= gpio   name= at90_tiny_mega \n    ...\n     notoggle   device-family= atmega   device-name= 8|16|32|64|128|162|8515|8535 True /notoggle \n     notoggle   device-family= attiny   device-name= 26 True /notoggle \n    ... /driver   Here the  notoggle  element will be added to the substitution dictionary only for the specified devices.", 
            "title": "Custom elements"
        }, 
        {
            "location": "/reference/device-files/#parameters", 
            "text": "In order to customize drivers further parameters may be declared.\nThere are currently three types available:   int : has a minimum and a maximum value  bool : true/false  enum : semicolon-separated values   All buffered UART implementations have two parameters named  tx_buffer  and  rx_buffer , which are of type  int  and set the size of the atomic transmit and receive buffer.  driver   type= uart   name= at90_tiny_mega \n    ...\n     parameter   name= tx_buffer   type= int   min= 1   max= 254 8 /parameter \n     parameter   name= rx_buffer   type= int   min= 1   max= 254 4 /parameter  /driver   Each UART instance receives their own two independent parameters with these default values.  The  stm32  core driver features the other two types:  driver   type= core   name= cortex \n     parameter   name= allocator   type= enum   values= newlib;block_allocator \n        block_allocator\n     /parameter \n     parameter   name= enable_gpio   type= bool true /parameter \n    ... /driver   These parameter may be overwritten in either the device file, or in the  project.cfg  in the section  [parameters] , which follows the naming scheme  type.name.instance.parameter :  [ parameters ]  uart . at90_tiny_mega . 0. tx_buffer   =   200  uart . at90_tiny_mega . 0. rx_buffer   =   100", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/device-files/#generator", 
            "text": "We designed the device file format to use this form of XML to not only be human readable, but much more important, to be human-writeable.  We decided to group multiple devices of the same functionality family into one device file, instead of providing one device file for each of these devices.  This made accessing the devices files computationally more complex, since we have to evaluate the device-scope, however, it dramatically reduces redundancies and allows a much more natural description of devices in this language.  While the first device files were still written manually, a device file generator soon became necessary to allow inclusion of many devices and to help with refactoring during API changes.  This generator uses multiple manufacturer provided description files to extract data about multiple devices and compress them into one device file, while preserving readability and correctness.  Further information about the device file generator can be found in the Readme at  /tools/device_file_generator .", 
            "title": "Generator"
        }
    ]
}